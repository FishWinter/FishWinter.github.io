<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>EASY</title>
  
  <subtitle>FishWinter</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yutianyao.top/"/>
  <updated>2019-11-14T06:12:18.636Z</updated>
  <id>http://yutianyao.top/</id>
  
  <author>
    <name>YTY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>新字符设备驱动实验1</title>
    <link href="http://yutianyao.top/3298061745.html"/>
    <id>http://yutianyao.top/3298061745.html</id>
    <published>2019-11-14T01:34:32.000Z</published>
    <updated>2019-11-14T06:12:18.636Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Nov 16 2019 19:01:46 GMT+0800 (CST) --><p>读正点原子所做的笔记</p><a id="more"></a><p>alloc_chrdev_region(&amp;dev_t,0,1,”test”)<br>申请设备号<br>我觉得这个比较常用<br>从0开始申请1个关于test的设备号<br>设备号保存在devid中</p><p>unregister_chrdev_region(dev_t, 1)<br>注销设备号<br>注销devid设备1个<br>这里有疑问,如果有3个次设备号呢,怎么确定注销哪一个?</p><p>定义cdev结构体<br>在include/linux/cdev.h这里面比较重要的是两个变量<br>const struct file_operations *ops 包含设备文件操作函数<br>dev_t 包含设备号</p><p>cdev_init(struct cdev *cdev,const struct file_operation *fops)<br>初始化cdev<br>第一个选项为未初始化的cdev<br>第二个选项为设备操作函数<br>设备操作函数定义 static struct file_operations test_fops = {<br>.owner = THIS_MODULE<br>}<br>testcdev.owner = THIS_MODULE</p><p>cdev_add(struct cdev *p,dev_t dev,unsigned count)<br>用于向linux系统添加字符设备<br>cdev_add(&amp;cdev, dev_t, 1)</p><p>cdev包含dev_t, file_operations</p><p>cdev_del(&amp;cdev)<br>删除cdev<br>和unregister_chrdev_region(dev_t, 1)注销设备号一起使用,那么建立也是一起cdev和alloc_chrdev_region</p><p>前面是自动获取设备号之后是自动创建设备节点<br>设备节点在/dev下.linux下是udev自动建立删除设备节点文件.用busybox构建的根文件系统中用的是简化版本mdev.插拔事件也是mdev管理</p><p>struct class class_create(struct module *owner, const char *name)<br>第一个参数为owner 一般为THIS_MODULE THIS_MODULE是什么?<br>第二个为类名字<br>返回值是指向结构体class的指针</p><p>void class_destroy(struct class *cls)<br>删除类</p><p>struct device *device_create( struct class *class<br>struct device *parent<br>dev_t devt<br>void *drvdata<br>const char *fmt,…)<br>创建设备,返回指向设备的指针<br>第一个为类<br>第二个parent为父参数,一般为NULL<br>第三个devt是设备号<br>第四个设备可能会使用的数据,一般为NULL<br>第五个设备名字<br>void device_destroy(struct *class, dev_t devt)</p><p>类和设备,先创建类在在类里创建设备,他们放在驱动入口函数</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Nov 16 2019 19:01:46 GMT+0800 (CST) --&gt;&lt;p&gt;读正点原子所做的笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="i.mx6ull" scheme="http://yutianyao.top/categories/i-mx6ull/"/>
    
    
      <category term="学习" scheme="http://yutianyao.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="linux" scheme="http://yutianyao.top/tags/linux/"/>
    
      <category term="嵌入式" scheme="http://yutianyao.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
</feed>
