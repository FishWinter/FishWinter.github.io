<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>EASY</title>
  
  <subtitle>FishWinter</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yutianyao.top/"/>
  <updated>2019-11-19T09:04:26.228Z</updated>
  <id>http://yutianyao.top/</id>
  
  <author>
    <name>YTY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设备树led驱动</title>
    <link href="http://yutianyao.top/aef9bc19.html"/>
    <id>http://yutianyao.top/aef9bc19.html</id>
    <published>2019-11-19T04:28:46.000Z</published>
    <updated>2019-11-19T09:04:26.228Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 19 2019 17:15:28 GMT+0800 (CST) --><p>读正点原子所做的笔记</p><a id="more"></a><p>本章的重点内容为:<br>创建设备节点,往里写入寄存器的地址<br>编写驱动程序,其中的驱动初始化里调用OF函数读取设备树里的地址完成初始化</p><p>alphaled{<br>#address-cells = &lt;1&gt;;<br>#size-cells = &lt;1&gt;;<br>compatible = “atkalpha-led”;<br>status = “okay”;<br>reg = &lt; 0X020C406C 0X04<br>0X020E0068 0X04 &gt;;<br>}<br>make dtbs 编译设备树</p><p>/* 获取设备节点: alphaled <em>/<br>dtsled.nd = of_find_node_by_path(“/alphaled”);<br>/</em> 获取compatible属性内容 <em>/<br>proper = of_find_property(dtsled.nd, “compatible”, NULL);<br>/</em> 获取status属性内容 <em>/<br>ret = of_property_read_string(dtsled.nd, “status”, &amp;str)<br>/</em> 获取reg属性内容 */<br>ret = of_property_read_u32_array(dtsled.nd, “reg”, regdata, 10);</p><p>后面的pinctrl和gpio子系统比现在用这个写方便多了</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Nov 19 2019 17:15:28 GMT+0800 (CST) --&gt;&lt;p&gt;读正点原子所做的笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="i.mx6ull" scheme="http://yutianyao.top/categories/i-mx6ull/"/>
    
    
      <category term="学习" scheme="http://yutianyao.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="linux" scheme="http://yutianyao.top/tags/linux/"/>
    
      <category term="嵌入式" scheme="http://yutianyao.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>linux设备树</title>
    <link href="http://yutianyao.top/f69a9274.html"/>
    <id>http://yutianyao.top/f69a9274.html</id>
    <published>2019-11-18T08:27:18.000Z</published>
    <updated>2019-11-18T13:49:52.436Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 19 2019 17:15:28 GMT+0800 (CST) --><p>读正点原子的设备树笔记</p><a id="more"></a><p>新版本linux中,arm相关的设备全部采用了设备树,很明显设备树非常重要</p><p>描述设备树的文件DTS(device tree source)还真是驱动 树 文件<br>一个描述soc的文件.dtsi<br>一个同样soc的不同板子的文件.dts</p><p>DTS编译后的二进制文件DTB,需要DTC工具编译<br>DTC存在linux内核的scripts/dtc目录下<br>编译设备树命令 make dtbs ,enmmm 直接编译这个soc下的所有板子的设备树文件dts</p><p>设备树dts里的 #include可以包含.h .dtsi .dts 但最好是.dtsi<br>.dtsi文件描述soc内部外设信息,比如CPU架构,主频,外设寄存器地址范围</p><p>设备节点<br>node-name@unit-address<br>node-name是节点名字,unit-adress表示设备的地址或寄存器首地址<br>unit-adress可以不要,为0<br>label:node-name@unit-address<br>可以直接通过label来访问这个节点,而不需要完整的节点名称<br>每个节点都有不同属性,不同属性又有不同内容,属性都是键值对,值可以为空或任意的字节流<br>字符串 compatible = “arm,cortex-a7”;<br>32位无符号整数 reg = &lt;0&gt;;也可以设为一组值 reg = &lt;0 123 0x123&gt;<br>字符串列表<br>compatible = “fsl,asd”,”fsl,dsa” 字符串之间用”,”分割</p><p>标准属性<br>compatible属性(兼容性属性)非常重要,字符串列表<br>用于将设备和驱动绑定<br>格式为”manufacturer,model”<br>manufacturer表示厂商, mode模块对应的驱动名字<br>驱动程序文件一般有一个OF匹配表,此表中保存着一些compatible值,如果设备的compatible属性值和OF匹配表中的任何一个值相等,那么就表示设备可以使用这个驱动</p><p>model属性<br>字符串,一般描述设备模块信息,比如名字什么</p><p>status属性<br>字符串,和设备状态有关<br>“okay”表明设备是可操作的<br>“disabled”表明当前是不可操作的,但以后可能为可操作的,比如热插拔设备<br>“fail”表面是不可操作的,有错误的<br>“fail-sss”和fail相同,sss是检测到的错误内容</p><p>“#address-cells和#size-cells属性”<br>这两个属性的值都是无符号32为整形,可以用在任何拥有子节点的设备中,用于描述子节点的地址信息<br>“#address-cells”决定子节点reg属性中地址信息所占用的字长,#size-cells决定长度信息所占的字长<br>reg=<address1 length1 address2 length2><br>‘#adress-cells表明address这个数据所占用的字长,#size-cells表明length这个数据所占用的字长</address1></p><p>reg属性<br>(address,length)</p><p>ranges属性<br>可以为空<br>子地址,父地址和地址空间长度,但是i.mx6ull子地址和父地址一样</p><p>name属性<br>记录节点名字,已启用</p><p>device_type属性<br>用于描述FCode?,只能用于cpu节点或者memory节点</p><p>OF操作函数</p><p>查找节点的OF函数,有5个<br>of_find_node_by_name函数通过节点名字查找指定的节点<br>of_find_node_by_type函数通过device_type属性查找指定的节点<br>of_find_compatible_node函数通过device_type和compatible两个属性查找<br>of_find_matching_node_and_match函数通过of_device_id匹配表查找<br>of_find_node_by_path函数通过路径来查找</p><p>查找父/子节点的OF函数<br>of_get_parent函数用来获取指定节点的父节点<br>of_get_next_child函数用迭代查找子节点</p><p>提取属性值的OF函数<br>of_find_property函数用于查找指定的数据<br>of_property_count_elems_of_size函数可以获取属性中元素的数量???<br>of_property_read_u32_index函数用于从属性中获取指定标号的u32类型数据值<br>这种函数或者使用用法可以从哪里获知呢?有什么东西储存这些吗?总不能一个一个去百度查吧</p><p>无法总结……….似懂非懂</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Nov 19 2019 17:15:28 GMT+0800 (CST) --&gt;&lt;p&gt;读正点原子的设备树笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="i.mx6ull" scheme="http://yutianyao.top/categories/i-mx6ull/"/>
    
    
      <category term="学习" scheme="http://yutianyao.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="linux" scheme="http://yutianyao.top/tags/linux/"/>
    
      <category term="嵌入式" scheme="http://yutianyao.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>写博客感受</title>
    <link href="http://yutianyao.top/65068efb.html"/>
    <id>http://yutianyao.top/65068efb.html</id>
    <published>2019-11-18T08:17:54.000Z</published>
    <updated>2019-11-18T13:49:35.024Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 19 2019 17:15:28 GMT+0800 (CST) --><p>写博客的感觉</p><a id="more"></a><p>刚修改了一下我写的第一篇博客,发现许多的不足之处.<br>文章写的很混乱,没有什么人会看这种,我自己也不会看,就没有什么复习的效果.<br>第一篇写完,还是有点感受,先写总结,在把总结里内容反着写出来.我觉得可以,下次试试.这博客更像是给我练习我打字速度的?和巩固我的知识,坚持写很难.总会有事,但未来时间会更少,还是珍惜一下眼前的时间的吧.下次有感的时候可以在写一篇感受.不错.</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Nov 19 2019 17:15:28 GMT+0800 (CST) --&gt;&lt;p&gt;写博客的感觉&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yutianyao.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="博客" scheme="http://yutianyao.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="感悟" scheme="http://yutianyao.top/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>新字符设备驱动实验</title>
    <link href="http://yutianyao.top/3298061745.html"/>
    <id>http://yutianyao.top/3298061745.html</id>
    <published>2019-11-14T01:34:32.000Z</published>
    <updated>2019-11-18T13:49:58.099Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 19 2019 17:15:28 GMT+0800 (CST) --><p>读正点原子所做的笔记</p><a id="more"></a><p>#创建(申请)设备号(alloc_chrdev_region)<br>alloc_chrdev_region(&amp;dev_t,0,1,”test”)<br>申请设备号<br>我觉得这个比较常用<br>从0开始申请1个关于test的设备号<br>设备号保存在devid中</p><p>unregister_chrdev_region(dev_t, 1)<br>注销设备号<br>注销devid设备1个<br>这里有疑问,如果有3个次设备号呢,怎么确定注销哪一个?</p><p>#初始化cdev(cdev_init)<br>定义cdev结构体<br>在include/linux/cdev.h这里面比较重要的是两个变量<br>const struct file_operations *ops 包含设备文件操作函数<br>dev_t 包含设备号</p><p>cdev_init(struct cdev *cdev,const struct file_operation *fops)<br>初始化cdev<br>第一个选项为未初始化的cdev<br>第二个选项为设备操作函数<br>设备操作函数定义 static struct file_operations test_fops = {<br>.owner = THIS_MODULE<br>}<br>testcdev.owner = THIS_MODULE</p><p>#添加一个cdev(cdev_add)<br>cdev_add(struct cdev *p,dev_t dev,unsigned count)<br>用于向linux系统添加字符设备<br>cdev_add(&amp;cdev, dev_t, 1)</p><p>cdev包含dev_t, file_operations</p><p>cdev_del(&amp;cdev)<br>删除cdev<br>和unregister_chrdev_region(dev_t, 1)注销设备号一起使用,那么建立也是一起cdev和alloc_chrdev_region</p><p>#创建类(class_create)<br>前面是自动获取设备号之后是自动创建设备节点<br>设备节点在/dev下.linux下是udev自动建立删除设备节点文件.用busybox构建的根文件系统中用的是简化版本mdev.插拔事件也是mdev管理<br>struct class class_create(struct module *owner, const char *name)<br>创建类<br>第一个参数为owner 一般为THIS_MODULE THIS_MODULE是什么?<br>第二个为类名字<br>返回值是指向结构体class的指针</p><p>void class_destroy(struct class *cls)<br>删除类</p><p>#创建设备(device_create)<br>struct device *device_create( struct class *class<br>struct device *parent<br>dev_t devt<br>void *drvdata<br>const char *fmt,…)<br>创建设备,返回指向设备的指针<br>第一个为类<br>第二个parent为父参数,一般为NULL<br>第三个devt是设备号<br>第四个设备可能会使用的数据,一般为NULL<br>第五个设备名字</p><p>void device_destroy(struct *class, dev_t devt)<br>删除设备</p><p>类和设备,先创建类在在类里创建设备,他们放在驱动入口函数</p><p>设置文件私有数据的时候用结构体表示更好</p><p>#总结:</p><p>先创建一个结构体,存放私有数据包括(设备号devid, cdev, 类<em>class, 设备</em>device, 主设备号major, 次设备号minor)<br>在初始化函数中<br>先创建(申请)设备号(alloc_chrdev_region)<br>初始化cdev(cdev_init)<br>添加一个cdev(cdev_add)<br>创建类(class_create)<br>创建设备(device_create)</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Nov 19 2019 17:15:28 GMT+0800 (CST) --&gt;&lt;p&gt;读正点原子所做的笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="i.mx6ull" scheme="http://yutianyao.top/categories/i-mx6ull/"/>
    
    
      <category term="学习" scheme="http://yutianyao.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="linux" scheme="http://yutianyao.top/tags/linux/"/>
    
      <category term="嵌入式" scheme="http://yutianyao.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
</feed>
